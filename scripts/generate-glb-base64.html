<!DOCTYPE html>
<html>
<head>
    <title>Generate GLB Base64</title>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <h1>Generate GLB Base64</h1>
    <button onclick="generateModels()">Generate Models</button>
    <pre id="output"></pre>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

        async function exportSceneToGLB(scene) {
            return new Promise((resolve, reject) => {
                const exporter = new GLTFExporter();
                exporter.parse(
                    scene,
                    (result) => {
                        if (result instanceof ArrayBuffer) {
                            resolve(result);
                        } else {
                            reject(new Error("Expected ArrayBuffer"));
                        }
                    },
                    (error) => reject(error),
                    { binary: true }
                );
            });
        }

        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = "";
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function calculateBoundingBox(geometry) {
            geometry.computeBoundingBox();
            const box = geometry.boundingBox;
            return {
                min: [box.min.x, box.min.y, box.min.z],
                max: [box.max.x, box.max.y, box.max.z],
            };
        }

        async function createBasicCube() {
            const scene = new THREE.Scene();
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({ color: 0x4ade80 });
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            const glb = await exportSceneToGLB(scene);
            const glbBase64 = arrayBufferToBase64(glb);

            return {
                type: "glb",
                glbBase64,
                metadata: {
                    vertices: geometry.attributes.position.count,
                    faces: geometry.index ? geometry.index.count / 3 : 0,
                    boundingBox: calculateBoundingBox(geometry),
                },
            };
        }

        async function createBasicSphere() {
            const scene = new THREE.Scene();
            const geometry = new THREE.SphereGeometry(0.5, 32, 32);
            const material = new THREE.MeshStandardMaterial({ color: 0x60a5fa });
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            const glb = await exportSceneToGLB(scene);
            const glbBase64 = arrayBufferToBase64(glb);

            return {
                type: "glb",
                glbBase64,
                metadata: {
                    vertices: geometry.attributes.position.count,
                    faces: geometry.index ? geometry.index.count / 3 : 0,
                    boundingBox: calculateBoundingBox(geometry),
                },
            };
        }

        async function createBasicCylinder() {
            const scene = new THREE.Scene();
            const geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
            const material = new THREE.MeshStandardMaterial({ color: 0xf472b6 });
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            const glb = await exportSceneToGLB(scene);
            const glbBase64 = arrayBufferToBase64(glb);

            return {
                type: "glb",
                glbBase64,
                metadata: {
                    vertices: geometry.attributes.position.count,
                    faces: geometry.index ? geometry.index.count / 3 : 0,
                    boundingBox: calculateBoundingBox(geometry),
                },
            };
        }

        window.generateModels = async function() {
            const output = document.getElementById('output');
            output.textContent = 'Generating models...';

            try {
                const cubeModel = await createBasicCube();
                const sphereModel = await createBasicSphere();
                const cylinderModel = await createBasicCylinder();

                const result = {
                    cubeModel,
                    sphereModel,
                    cylinderModel
                };

                output.textContent = JSON.stringify(result, null, 2);
                console.log('Copy this output to your seed.ts file');
            } catch (error) {
                output.textContent = 'Error: ' + error.message;
                console.error(error);
            }
        };
    </script>
</body>
</html>
